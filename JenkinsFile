pipeline {
    agent any

    environment {
        APP_NAME = "users"
        SONAR_TOKEN = credentials('sonarcloud-token')
        VERSION_FILE = "stable_version.txt"
        IMAGE_NAME = 'lmsusers'
        IMAGE_TAG = "${APP_NAME}-${env.GIT_COMMIT}"
        DOCKER_REPO = "vitorcosta30/odsoft_1170623_1201391"
        HEALTHCHECK_URL = "http://host.docker.internal:8888/actuator/health"
        STABLE_BUILD_TAG = "users-prod-stable"
        ADMIN1 = "1201391@isep.ipp.pt"
        ADMIN2 = "1170623@isep.ipp.pt"

    }

    options {
        skipDefaultCheckout(true)
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out source for branch: ${env.BRANCH_NAME}"
                script {
                    def scmVars = checkout scm
                    env.GIT_COMMIT = scmVars.GIT_COMMIT
                    echo "Current commit hash: ${env.GIT_COMMIT}"
                    IMAGE_TAG = "${APP_NAME}-${env.GIT_COMMIT}"
                }
            }
        }


        stage('Build') {
            steps {
                echo "Building ${APP_NAME} for branch: ${env.BRANCH_NAME}"
                script{
                    sh 'mvn clean compile -B'
                }
            }
        }

        stage('Tests') {
            steps {
                echo "Running unit tests for ${APP_NAME}..."
                script{
                    catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
                        sh 'mvn test verify'
                    }
                }
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                    recordCoverage(
                        tools: [[parser: 'JACOCO', pattern: 'target/site/jacoco/jacoco.xml']],
                        id: 'jacoco-unit',
                        name: 'JaCoCo Unit Coverage',
                        sourceCodeRetention: 'LAST_BUILD',
                        sourceDirectories: [[path: 'src/main/java'], [path: 'target/generated-sources/annotations']],
                        qualityGates: [
                            [metric: 'LINE',   baseline: 'PROJECT', threshold: 80.0, criticality: 'NOTE'],
                            [metric: 'BRANCH', baseline: 'PROJECT', threshold: 70.0, criticality: 'NOTE']
                        ]
                    )
                    junit '**/target/failsafe-reports/*.xml'
                    recordCoverage(
                        tools: [[parser: 'JACOCO', pattern: 'target/site/jacoco-it/jacoco.xml']],
                        id: 'jacoco-it',
                        name: 'JaCoCo IT Coverage',
                        sourceCodeRetention: 'LAST_BUILD',
                        sourceDirectories: [[path: 'src/main/java'], [path: 'target/generated-sources/annotations']],
                        qualityGates: [
                            [metric: 'LINE',   baseline: 'PROJECT', threshold: 80.0, criticality: 'NOTE'],
                            [metric: 'BRANCH', baseline: 'PROJECT', threshold: 70.0, criticality: 'NOTE']
                        ]
                    )

                }
            }
        }
        stage('Mutation Tests') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
                    sh 'mvn org.pitest:pitest-maven:mutationCoverage'
                }
            }
            post {
                always {
                    recordCoverage(
                        tools: [[parser: 'PIT', pattern: 'target/pit-reports/latest/mutations.xml']],
                        id: 'pit',
                        name: 'PIT Mutation Coverage',
                        sourceCodeRetention: 'LAST_BUILD',
                        sourceDirectories: [[path: 'src/main/java'], [path: 'target/generated-sources/annotations']],
                        qualityGates: [[metric: 'MUTATION', baseline: 'PROJECT', threshold: 70.0, criticality: 'NOTE']]
                    )
                }
            }
        }


        stage('Static Code Analysis') {
            steps {
                withSonarQubeEnv('SonarCloud') {
                    sh "mvn sonar:sonar "
                }
            }
        }

         stage('Archive JAR file'){
             steps{
                 script {
                     if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                         echo "Build successful, archiving stable build."

                         if (!fileExists(VERSION_FILE)) {
                             writeFile file: VERSION_FILE, text: '-1'
                         }

                         def currentVersion = readFile(VERSION_FILE).trim().toInteger()
                         def newVersion = currentVersion + 1
                         def stableTag = "stable-v1.${newVersion}"

                         dir('target') {
                             if (isUnix()) {
                                 sh "mv *.jar ${stableTag}.jar"
                             } else {
                                 bat "rename *.jar ${stableTag}.jar"
                             }
                         }
                         archiveArtifacts 'target/*.jar'

                         writeFile file: VERSION_FILE, text: "${newVersion}"
                     } else {

                         echo "Archiving JAR file"
                         archiveArtifacts 'target/*.jar'

                     }
                 }
             }
         }
         stage('Build Docker Image') {
            steps {
              script {
                echo "Building and tagging the Docker image"
                sh """
                docker build -t ${DOCKER_REPO}:${IMAGE_TAG} .
                """
              }
            }
         }

         stage('Archive Container Image') {
             steps {
                echo "Archiving Dockerfile and metadata"
                archiveArtifacts artifacts: 'Dockerfile, **/metadata/*.json'

             }
         }



        stage('Production Deploy notification') {
            when {
                anyOf {
                    branch 'main'
                }
            }
            steps {
                script {
                    mail to:"${ADMIN1},${ADMIN1}",
                        subject: "Build # $BUILD_NUMBER - App $APP_NAME - To be deployed to production",
                        body: """
                        Build # $BUILD_NUMBER :

                        Check console output at $BUILD_URL to view the results.
                        """

                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    echo "Pushing Docker image to Docker Hub"
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials',
                     usernameVariable: 'DOCKER_USERNAME',
                     passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh """
                        echo ${DOCKER_PASSWORD} | docker login -u ${DOCKER_USERNAME} --password-stdin
                        docker push ${DOCKER_REPO}:${IMAGE_TAG}
                        """
                    }
                }
            }
        }



        stage('Deploy with Docker Compose') {
            steps {
                script {
                    if (env.BRANCH_NAME == 'dev') {
                        echo "Deploying ${APP_NAME} to DEV environment..."
                        sh """
                                if ! docker ps --filter "name=rabbitmq_dev" --format '{{.Names}}' | grep -q rabbitmq_dev; then
                                  docker compose -f docker-compose.infra.dev.yaml up -d rabbitmq_dev
                                else
                                  echo "RabbitMQ container already running."
                                fi
                            if  docker ps --filter "name=lmsusers_dev" --format '{{.Names}}' | grep -q lmsusers_dev; then
                              docker compose -f docker-compose.dev.yaml down
                            fi
                            DOCKER_TAG=${IMAGE_TAG} docker compose -f docker-compose.dev.yaml up -d
                        """
                    } else if (env.BRANCH_NAME == 'staging') {
                        echo "Deploying ${APP_NAME} to STAGING environment..."
                        sh """
                            if ! docker ps --filter "name=rabbitmq_staging" --format '{{.Names}}' | grep -q rabbitmq_staging; then
                              docker compose -f docker-compose.infra.staging.yaml up -d rabbitmq_staging
                            else
                              echo "RabbitMQ container already running."
                            fi

                            if ! docker ps --filter "name=db_staging" --format '{{.Names}}' | grep -q db_staging; then
                              docker compose -f docker-compose.infra.staging.yaml up -d db_staging
                            else
                              echo "Postgres container already running."
                            fi

                            if  docker ps --filter "name=lmsusers-staging" --format '{{.Names}}' | grep -q lmsusers-staging; then
                              docker compose -f docker-compose.staging.yml down
                            fi
                            DOCKER_TAG=${IMAGE_TAG} docker compose -f docker-compose.staging.yml up -d
                        """
                    } else if (env.BRANCH_NAME == 'main') {
                        sh """
                            if ! docker ps --filter "name=rabbitmq_in_lms_network" --format '{{.Names}}' | grep -q rabbitmq_in_lms_network; then
                              docker compose -f docker-compose.infra.prod.yml up -d rabbitmq_in_lms_network
                            else
                              echo "RabbitMQ container already running."
                            fi

                            if ! docker ps --filter "name=postgres_in_lms_network" --format '{{.Names}}' | grep -q postgres_in_lms_network; then
                              docker compose -f docker-compose.infra.prod.yml up -d postgres_in_lms_network
                            else
                              echo "Postgres container already running."
                            fi

                            if ! docker ps --filter "name=lmsusers_lb" --format '{{.Names}}' | grep -q lmsusers_lb; then
                              DOCKER_TAG=${IMAGE_TAG} docker compose -f docker-compose.yml up -d --build lmsusers_lb
                            else
                              echo "Load balancer container already running."
                            fi


                            if ! docker ps --filter "name=users1_in_lms_network" --format '{{.Names}}' | grep -q users1_in_lms_network; then
                              DOCKER_TAG=${IMAGE_TAG} docker compose -f docker-compose.yml up -d lmsusers_1
                            else
                              echo "Replacing instance 1 of users Microservice."
                              docker compose -f docker-compose.yml stop lmsusers_1
                              DOCKER_TAG=${IMAGE_TAG} docker compose -f docker-compose.yml up -d lmsusers_1
                            fi
                            echo "Waiting for instance 1 to start up."
                            sleep 5

                            if ! docker ps --filter "name=users2_in_lms_network" --format '{{.Names}}' | grep -q users2_in_lms_network; then
                              DOCKER_TAG=${IMAGE_TAG} docker compose -f docker-compose.yml up -d lmsusers_2
                            else
                              echo "Replacing instance 2 of users Microservice."
                              docker compose -f docker-compose.yml stop lmsusers_2
                              DOCKER_TAG=${IMAGE_TAG} docker compose -f docker-compose.yml up -d lmsusers_2
                            fi
                        """
                    } else {
                        echo "Branch ${env.BRANCH_NAME} is not configured for deployment."
                    }
                }
            }
        }



        stage('Smoke Tests') {
            when {
                anyOf {
                    branch 'dev'
                    branch 'staging'
                }
            }
            steps {
                script {
                    echo "Running smoke tests for ${APP_NAME} in ${env.BRANCH_NAME} environment..."

                    def networkName = (env.BRANCH_NAME == 'dev') ? 'dev_network' : 'staging_network'
                    def serviceName = (env.BRANCH_NAME == 'dev') ? 'lmsusers-dev' : 'lmsusers-staging'

                    def maxRetries = 5
                    def waitSeconds = 5
                    def smokePassed = false

                    for (int i = 1; i <= maxRetries; i++) {
                        def status = sh(
                            script: """
                            docker run --rm --network ${networkName} curlimages/curl:latest -s -o /dev/null -w '%{http_code}' http://${serviceName}:8088/actuator/health || true
                            """,
                            returnStdout: true
                        ).trim()

                        if (status == "200") {
                            echo "Smoke test passed on attempt ${i}"
                            smokePassed = true
                            break
                        }

                        echo "Attempt ${i}/${maxRetries} failed (status ${status}). Retrying in ${waitSeconds}s..."
                        sleep(waitSeconds)
                    }

                    if (!smokePassed) {
                        error("Smoke tests FAILED. Aborting further deployment.")
                    }
                }
            }
        }



        stage('Production Health Check') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "Running production health checks..."

                    def maxRetries = 30
                    def waitSeconds = 5
                    def healthy = false

                    for (int i = 1; i <= maxRetries; i++) {
                        def status = sh(
                            script: "curl -s -o /dev/null -w '%{http_code}' ${HEALTHCHECK_URL} || true",
                            returnStdout: true
                        ).trim()

                        if (status == "200") {
                            echo "Health check passed on attempt ${i}"
                            healthy = true
                            break
                        }

                        echo "Attempt ${i}/${maxRetries} failed (status ${status}). Retrying in ${waitSeconds}s..."
                        sleep(waitSeconds)
                    }

                    if (!healthy) {
                        error("Production health check FAILED")
                    }
                }
            }
        }

        stage('Staging Load Tests') {
            when {
                branch 'staging'
            }
            steps {
                script {
                    echo "Running load tests in staging network"

                    sh """
                        docker compose -f docker-compose.k6.staging.yml run --name k6_staging_run k6
                        docker cp k6_staging_run:/load-tests/results.json load-tests/results.json
                        docker rm k6_staging_run
                    """
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'load-tests/results.json', fingerprint: true
                }
            }
        }


        stage('Promote Image to stable') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "Promoting ${IMAGE_TAG} to prod-stable"

                    sh """
                        docker pull ${DOCKER_REPO}:${IMAGE_TAG}
                        docker tag ${DOCKER_REPO}:${IMAGE_TAG} ${DOCKER_REPO}:${STABLE_BUILD_TAG}
                        docker push ${DOCKER_REPO}:${STABLE_BUILD_TAG}
                    """
                }
            }
        }

    }

    post {
        always {
            echo "Pipeline completed for branch: ${env.BRANCH_NAME}"
        }
        success {
            echo "Pipeline successful!"
            /**script {
                if (env.BRANCH_NAME == 'staging' || env.BRANCH_NAME == 'dev') {
                    echo "Running health checks for ${env.BRANCH_NAME} environment"

                    def serverAddress = 'localhost'
                    def port = (env.BRANCH_NAME == 'staging') ? 8887 : 8886
                    def maxRetries = 30
                    def waitSeconds = 10
                    def success = false

                    for (int i = 1; i <= maxRetries; i++) {
                        def response = sh(
                            script: "ncat -zv ${serverAddress} ${port} 2>&1 || true",
                            returnStdout: true
                        ).trim()

                        if (response.contains("Connected to")) {
                            echo "Health check passed: Service is up on port ${port} (attempt ${i})"
                            success = true
                            break
                        } else {
                            echo "Attempt ${i}/${maxRetries}: Service not reachable yet on port ${port}. Retrying in ${waitSeconds}s..."
                            sleep(waitSeconds)
                        }
                    }

                    if (!success) {
                        error("Health check failed: Service did not start within ${maxRetries * waitSeconds} seconds on port ${port}")
                    }
                }
            }**/

        }
        failure {
            script {
                if (env.BRANCH_NAME == 'main') {
                    echo "Deployment failed. Rolling back to last stable build"
                    sh """
                        docker pull ${DOCKER_REPO}:${STABLE_BUILD_TAG}
                        if ! docker ps --filter "name=users1_in_lms_network" --format '{{.Names}}' | grep -q users1_in_lms_network; then
                          DOCKER_TAG=${STABLE_BUILD_TAG} docker compose -f docker-compose.yml up -d lmsusers_1
                        else
                          echo "Replacing instance 1 of users Microservice."
                          docker compose -f docker-compose.yml stop lmsusers_1
                          DOCKER_TAG=${STABLE_BUILD_TAG} docker compose -f docker-compose.yml up -d lmsusers_1
                        fi
                        echo "Waiting for instance 1 to start up."
                        sleep 5

                        if ! docker ps --filter "name=users2_in_lms_network" --format '{{.Names}}' | grep -q users2_in_lms_network; then
                          DOCKER_TAG=${STABLE_BUILD_TAG} docker compose -f docker-compose.yml up -d lmsusers_2
                        else
                          echo "Replacing instance 2 of users Microservice."
                          docker compose -f docker-compose.yml stop lmsusers_2
                          DOCKER_TAG=${STABLE_BUILD_TAG} docker compose -f docker-compose.yml up -d lmsusers_2
                        fi
                    """

                    echo "Rollback to prod-stable completed"
                }
            }

        }
    }
}